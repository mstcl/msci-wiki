---
title: Single density network
jupyter: python3
execute:
  cache: true
---

## Import and define functions

```{python}
#| code-fold: true
import os
os.chdir("/hades/projects/persistent-exclusion-process/")
import numpy as np
import h5py
import glob
import re
import tensorflow as tf
from tensorflow import keras
from keras import backend as K
import gc
import matplotlib.pyplot as plt
from scipy.stats import pearsonr

np.set_printoptions(precision=3, suppress=True)
```

```{python}
#| code-fold: true
def reset(all=False):
    K.clear_session()
    global prediction, x, y, x_train, y_train, x_val, y_val
    del prediction
    if all:
        del x
        del y
        del x_train
        del y_train
        del x_val
        del y_val
    print("Collected: ", gc.collect())


def extract_floats(string):
    return re.findall(r"[-+]?\d*\.\d+|\d+", string)


def data_load(density):
    files = glob.glob(f"no_roll_data/dataset_tumble_*_{density}.h5")
    inputs,outputs = [],[]
    for f in files:
        tumble = float(extract_floats(f)[0])
        with h5py.File(f, "r") as fin:
          count = 0
          for key in fin.keys():
              img = fin[key][:]
              img = img.reshape((img.shape[0], img.shape[1],1))
              shape = img.shape
              inputs.append(img)
              outputs.append(tumble)
              count+=1

    # Scramble the dataset
    order = np.arange(len(outputs)).astype(int)
    order = np.random.permutation(order)
    return np.array(inputs)[order],np.array(outputs)[order],shape


def split_dataset(x,y,last=2000):
    print("Number of unique alpha: ", len(np.unique(y)))
    print("Shape of x: ", np.shape(x))
    print("Shape of y: ", np.shape(y))

    x_train, y_train = x[:-last], y[:-last]
    x_val,y_val = x[-last:],y[-last:]

    print("Size of training data: ", len(x_train))
    print("Size of validation data: ", len(x_val))
    return x_train, y_train, x_val, y_val


def get_model_prediction(name,x_val):
    model = tf.keras.models.load_model(f'models/{name}.keras')
    prediction = model.predict(x_val, batch_size=64)
    return prediction

def make_plot(y_val, prediction):
    plt.plot(y_val, prediction.T[0], 'o', c='k', alpha=0.25)
    plt.plot(y_val, y_val, 'o', color='r')

    print("Pearson's correlation coeff: ", pearsonr(y_val, prediction.T[0]).statistic)
    plt.xlabel("Input turning rate")
    plt.ylabel("Predicted turning rate")
    plt.axis("equal")
    plt.xscale("log")
    plt.yscale("log")
    plt.show()
```

## Predict with the same density

```{python}
density = 0.15
validation_size = 2000
x,y,shape = data_load(density=density)
x_train, y_train, x_val, y_val = split_dataset(x,y,last=validation_size)
```

### Basic model

```{python}
prediction = get_model_prediction("basic_0.15", x_val)
make_plot(y_val, prediction)
```

### With a dropout layer

```{python}
reset()
```

```{python}
prediction = get_model_prediction("with_dropout_0.15", x_val)
make_plot(y_val, prediction)
```

### Without a dropout layer

```{python}
reset()
```

```{python}
prediction = get_model_prediction("without_dropout_0.15", x_val)
make_plot(y_val, prediction)
```

## Predict with slightly higher density

```{python}
reset(all=True)
```

```{python}
density = 0.25
validation_size = 2000
x,y,shape = data_load(density=density)
x_train, y_train, x_val, y_val = split_dataset(x,y,last=validation_size)
```

### Basic model

```{python}
prediction = get_model_prediction("basic_0.15", x_val)
make_plot(y_val, prediction)
```

### With a dropout layer

```{python}
reset()
```

```{python}
prediction = get_model_prediction("with_dropout_0.15", x_val)
make_plot(y_val, prediction)
```

### Without a dropout layer

```{python}
reset()
```

```{python}
prediction = get_model_prediction("without_dropout_0.15", x_val)
make_plot(y_val, prediction)
```

## Predict with much higher density

```{python}
reset(all=True)
```

```{python}
density = 0.45
validation_size = 2000
x,y,shape = data_load(density=density)
x_train, y_train, x_val, y_val = split_dataset(x,y,last=validation_size)
```

### Basic model

```{python}
prediction = get_model_prediction("basic_0.15", x_val)
make_plot(y_val, prediction)
```

### With a dropout layer

```{python}
reset()
```

```{python}
prediction = get_model_prediction("with_dropout_0.15", x_val)
make_plot(y_val, prediction)
```

### Without a dropout layer

```{python}
reset()
```

```{python}
prediction = get_model_prediction("without_dropout_0.15", x_val)
make_plot(y_val, prediction)
```
